'use strict';

var async = require('async');
var Chance = require('chance');
var logger = require('winston');
var mongoose = require('mongoose');

var SimType = require('../models/sim-type-model').SimType;

// GET /sim-types
exports.list = function (req, res) {
   if (!req.session || !req.session.userId) return res.send(401);

   var query = { 'experimenter._id': req.session.userId };
   if (req.query.status) query.status = req.query.status;

   SimType.find().exec(function findCb(err, simTypes) {
      if (err) {
         logger.error('Error on GET /sim-types', err);
         return res.send(500);
      }

      return res.status(200).send(simTypes);
   });
};


// POST /sim-types
exports.create = function (req, res) {
   // TODO - these session validations can be performed by middleware
   if (!req.session || !req.session.userId) return res.send(401);

   // TODO - validate here again

   var st = {
      name: req.body.name,
      experimenter: {
         _id: req.session.userId,
         username: req.session.username
      },
      desc: req.body.desc,
      status: 'test',
      dateCreated: new Date(),
      dateActive: null,
      dateArchived: null,
      numCompleted: 0,
      numAborted: 0,
      params: req.body
   };

   // Don't repeat name and description
   delete st.params.name;
   delete st.params.desc;

   // We need an autogenerated code
   var chance = new Chance();
   var foundNewCode = false;
   var tries = 0;

   async.waterfall([
      function generateCode(next) {
         async.doUntil(
            function newCode(cb) {
               st.code = chance.string({
                  length: 6,
                  pool: 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'
               });
               tries += 1;

               SimType.findOne(
                  {'code': st.code},
                  function onFound(err, found) {
                     if (err) return cb(err);
                     if (tries > 10) {
                        return cb({
                           message: 'Error generating microworld code: ' +
                              'too many tries'});
                     }
                     if (!found) foundNewCode = true;
                     return cb();
                  });
            },
            function checkIfFound() {
               return foundNewCode;
            },
            function (err) {
               if (err) return next({status: 500, message: err.message});
               return next();
            }
         );
      }, function createSimType(next) {
         SimType.create(st, function onCreate(err, stRes) {
            if (err) return next({status: 500, message: err.message});

            return next(null, stRes);
         });
      }
   ], function resolve(err, stRes) {
      // TODO - log errors
      if (err) return res.status(err.status).send(err.message);
      return res.status(200).send(stRes);
   });
}